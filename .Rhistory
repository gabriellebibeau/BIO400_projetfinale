}
plot(maximum~c(0:(annees-1)), type='l', lty=2, xlab='Ann�es', ylab='N', main='Trajectoire moyenne et I.C. 95%')
lines(minimum~c(0:(annees-1)), type='l', lty=2)
lines(moyen~c(0:(annees-1)), type='l', lty=1)
return(list('INF'=minimum,'MOY'=moyen,'SUP'=maximum, 'ECART'=ecart))
}
#fonction qui calcule une trajectoire avec de la stochasticit� d�mographique en plus d'environnementale
popgrowth.S=function(Nzero,annees,moyR,ecartR, S)
{
vec.N=rep(NA,times=annees+1)
vec.N[1]=Nzero
vec.annees=c(0:annees)
vec.R=rep(NA,times=annees+1)
for (i in 1:annees){
vec.R[i]=rnorm(1,moyR,ecartR)
f=vec.R[i]-S
if (f>=1) f=0.999
if (f>=0) { vec.N[i+1]=rbinom(1,vec.N[i],S) + rbinom(1,vec.N[i],f) }
if (f<0) { vec.N[i+1]=rbinom(1,vec.N[i],S) - rbinom(1,vec.N[i],abs(f))}
}
return(list('R'=vec.R, 'N'=vec.N))
}
#fonction qui calcule plusieurs trajectoires avec stochasticit� d�mographique
sim.popgrowth.S=function(x,Nzero,annees,moyR,ecartR,S)
{
mat.N=NULL
mat.R=NULL
vec.annees=c(0:annees)
for (j in (1:x)){
calcul=popgrowth.S(Nzero,annees,moyR,ecartR,S)
mat.N=cbind(mat.N,calcul$N)
mat.R=cbind(mat.R,calcul$R)
}
return(list('matN'=mat.N,'matR'=mat.R))
}
#fonction pour quasi-extinction curve
quasi.ext=function(results,x)
{
vec.risk=apply(results$matN[-1,],2,min)
borne.g=floor(min(vec.risk)-3)
borne.d=ceiling(max(vec.risk)+3)
classes=seq(borne.g,borne.d,1)
freqs=cut(vec.risk,classes,right=F)
freqs2=table(freqs)
freqs.cum=(cumsum(freqs2))/x
plot(freqs.cum~classes[-1],xlab='N',ylab='Probabilit�',type='l', main='Courbe de quasi-extinction')
return(list('FREQ'=freqs.cum))
}
#fonction pour quasi-explosion curve
quasi.exp=function(results,x)
{
vec.risk=apply(results$matN[-1,],2,max)
borne.g=floor(min(vec.risk)-3)
borne.d=ceiling(max(vec.risk)+3)
classes=seq(borne.g,borne.d,1)
freqs=cut(vec.risk,classes,right=F)
freqs2=table(freqs)
freqs.cum=1-(cumsum(freqs2))/x
plot(freqs.cum~classes[-1],xlab='N',ylab='Probabilit�',type='l', main='Courbe de quasi-explosion')
return(list('FREQ'=freqs.cum))
}
plot(es1$N~c(0:12), type='1')
plot(es1$N~c(0:12), type='1')
plot(es1$N~c(0:12), type='1')
plot(es1$N~c(0:12))
#2 ajout stochasticite
es2 <- popgrowth(Nzero = 31, annees = 12, moyR = 1.148, ecartR = 0.075)
plot(es2$N~c(0:12))
View(es2)
#3 plsr trajectoires
es3 <- sim.popgrowth(x=1000, Nzero = 31, annees = 12, moyR = 1.148, ecartR = 0)
View(es3)
es3[["matN"]]
es3$matN
es3$matR
plot(es3$N~c(0:12))
plot(es3$N[1,]~c(0:12))
plot(es3$N[,1]~c(0:12))
sim.plot(es3)
sim.plot(es3)
res3 <- avg.plot(es3)
#on voit courbe avc 0.05 des resultats (non significatifs) absent
res3
#3 plsr trajectoires
es3 <- sim.popgrowth(x=1000, Nzero = 31, annees = 12, moyR = 1.148, ecartR = 0.075)
sim.plot(es3)
res3 <- avg.plot(es3)
#on voit courbe avc 0.05 des resultats (non significatifs) absent
res3
#4 + de stoschasticite
es4 <- sim.popgrowth.S(x=1000, Nzero = 31, annees = 12, moyR = 1.148, ecartR = 0.075, S=0.921)
sim.plot(es4)
sim.plot(es3)
sim.plot(es4)
res4 <- avg.plot(es4)
res4
res3 <- avg.plot(es3)
res4 <- avg.plot(es4)
#5 quasi-extinction
ext5 <- quasi.ext(es4, 1000)
#6 quasi-explosion
exp6 <- quasi.exp(es4, 1000)
View(exp6)
exp6[["FREQ"]]
#7 sensibilite
es4 <- sim.popgrowth.S(x=2000, Nzero = 31, annees = 12, moyR = 1.148, ecartR = 0.075, S=0.921)
sim.plot(es4)
res4 <- avg.plot(es4)
sim.plot(es4)
es7 <- sim.popgrowth.S(x=1000, Nzero = 15, annees = 12, moyR = 1.148, ecartR = 0.075, S=0.921)
sim.plot(es7)
res7 <- avg.plot(es7)
es7 <- sim.popgrowth.S(x=1000, Nzero = 31, annees = 30, moyR = 1.148, ecartR = 0.075, S=0.921)
sim.plot(es7)
res7 <- avg.plot(es7)
es7 <- sim.popgrowth.S(x=1000, Nzero = 31, annees = 12, moyR = 2, ecartR = 0.075, S=0.921)
sim.plot(es7)
res7 <- avg.plot(es7)
es7 <- sim.popgrowth.S(x=1000, Nzero = 31, annees = 12, moyR = 1.148, ecartR = 0.2, S=0.921)
sim.plot(es7)
res7 <- avg.plot(es7)
es7 <- sim.popgrowth.S(x=1000, Nzero = 31, annees = 12, moyR = 1.148, ecartR = 0.075, S=0.8)
sim.plot(es7)
res7 <- avg.plot(es7)
dbinom(4, 8, 0.5)
pbinom(4,8,0.5)
#Recreer les donnees fournies par l'entreprise
ab_nerprun <- c(959, 932, 579, 1079, 176, 488, 623, 408)
ab_cerf <- c(8.74, 2.79, 7.56, 10.84, 2.96, 1.90, 3.06, 6.72)
id_parcelle <- seq(8)
d.i <- data.frame(id_parcelle, ab_nerprun, ab_cerf)
#les caracteristiques des donnees de l'entreprises
moy.ab.ner.initial <- mean(d.i$ab_nerprun)
moy.ab.cerf.initial <- mean(d.i$ab_cerf)
sd.ab.nerprun <- sd(d.i$ab_nerprun)
sd.ab.cerf <- sd(d.i$ab_cerf)
donnees.i.ner <- rnorm(100, moy.ab.ner.initial, sd.ab.nerprun)
donnees.i.cerf <- rnorm(100, moy.ab.cerf.initial, sd.ab.cerf)
summary(lm(donnees.i.ner ~ donnees.i.cerf))
n <- c(10,20,40,60,100)
effets <- c(0.5, 2.5, 4.3, 5, 8)
source("C:/Users/Gabib/Downloads/Projet_final (3).R", echo=TRUE)
#Fonction pour calculer la puissance
puissance <- function(n, beta0, effet, sd.ab.ner){
output <- rep(NA,10000)
for(i in 1:10000){
x <- round(15*runif(n))
sample <- rnorm(n, mean=beta0+effet*x, sd=sd.ab.ner)
test <- summary(lm(sample~x)) #On test H0 a l'aide d'un test de t de Student.
output[i] <- test$coefficients[2,4] #On garde la valeur de P du test.
}
sign <- output<=0.05 #On identifie les tests de t significatifs (i.e., où H0 a été rejetée) au seuil alpha*=0.05
sum(sign)/10000 #Puissance
}
#Appliquer la fonction a differents effets
effort <- c(10,20,40,60,100)
effets <- c(0.5, 2.5, 4.3, 5, 8)
data <- matrix(ncol=3, nrow=25, dimnames = list(c(1:25),c("n", "taille.effet", "puissance")))
for (y in 1:length(effort)){
for (i in 1:length(effets)){
n<- effort[y]
p <- puissance(n, 10, effets[i], sd.ab.nerprun)
data[i+((y-1)*5),] <- c(n, effets[i], p)
}
}
data
ab_nerprun <- c(959, 932, 579, 1079, 176, 488, 623, 408)
ab_cerf <- c(8.74, 2.79, 7.56, 10.84, 2.96, 1.90, 3.06, 6.72)
id_parcelle <- seq(8)
d.i <- data.frame(id_parcelle, ab_nerprun, ab_cerf)
sd.ab.nerprun <- sd(d.i$ab_nerprun)
n <- c(10,20,40,60,100)
#Fonction pour calculer la puissance à l'aide d'une simulation de Monte Carlo
puissance <- function(n, beta0, effet, sd.ab.ner){
output <- rep(NA,10000)
for(i in 1:10000){
x <- round(12*runif(n))
sample <- rnorm(n, mean=beta0+effet*x, sd=sd.ab.ner)
test <- summary(lm(sample~x))
output[i] <- test$coefficients[2,4] #On garde la valeur de P de la pente
}
sign <- output<=0.05 #On identifie les tests de t significatifs (i.e., où H0 a été rejetée) au seuil alpha*=0.05
sum(sign)/10000 #Puissance
}
effort <- c(10, 20, 40, 60, 100)
effets <- c(5, 10, 20, 30, 50)
data <- matrix(ncol=3, nrow=25, dimnames = list(c(1:25),c("n", "taille.effet", "puissance")))
for (y in 1:length(effort)){
for (i in 1:length(effets)){
n<- effort[y]
p <- puissance(n, 100, effets[i], sd.ab.nerprun) #100=intercept random
data[i+((y-1)*5),] <- c(n, effets[i], p)
}
}
data <- data.frame(data)
View(data)
install.packages("DADA2")
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("dada2", version = "3.11")
BiocManager::install("dada2", version = "3.18")
source("~/Baccalauréat/H24/BIO401/Devoir1_Question1_b.R", echo=TRUE)
View(Preuve)
print(preuve)
View(Preuve)
source("~/Baccalauréat/H24/BIO401/Devoir1_Question1_b.R", echo=TRUE)
View(Preuve)
install.packages("mpower")
library(mpower)
source("~/Baccalauréat/H24/BIO401/Devoir1_Question1_b.R", echo=TRUE)
install.packages("expm")
library(expm)
source("~/Baccalauréat/H24/BIO401/Devoir1_Question1_b.R", echo=TRUE)
View(Preuve)
a1 <- c(0,0.01,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.23,0.04,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0.51,0.22,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.6,0.3,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0.65,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.67,0.15,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.54,0.3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.66,
0.23,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.7,0.05,0,0,0,0,0,0,0,0,1900,0,0,
0,0,0,0,0,0,0.6,0.5,0,0,0,0,0,0,0,2100,0,0,0,0,0,0,0,0,0,0.43,0.25,0,0,0,
0,0,0,2200,0,0,0,0,0,0,0,0,0,0,0.12,0.08,0,0,0,0,0,1800,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,1700,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1900,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,1,0,0,2100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,2300,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,1,2000,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
Mat_L_anguille <- matrix(a1, 18, 18)
#matrice a puissance positive - preuve
Preuve <- Mat_L_anguille%^%(18^(2) - (2*18) + 2)
View(Preuve)
a1 <- c(0,0.01,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.23,0.04,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0.51,0.22,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.6,0.3,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0.65,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.67,0.15,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.54,0.3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.66,
0.23,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.7,0.05,0,0,0,0,0,0,0,0,1900,0,0,
0,0,0,0,0,0,0.6,0.5,0,0,0,0,0,0,0,2100,0,0,0,0,0,0,0,0,0,0.43,0.25,0,0,0,
0,0,0,2200,0,0,0,0,0,0,0,0,0,0,0.12,0.08,0,0,0,0,0,1800,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,1700,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1900,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,1,0,0,2100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,2300,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,1,2000,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
Mat_L_anguille <- matrix(a1, 18, 18)
#matrice a puissance positive - preuve
Preuve <- Mat_L_anguille%^%(18^(2) - (2*18) + 2)
View(propre)
View(Preuve)
#valeur propre (ou vecteur?)
propre <- eigen(Mat_L_anguille, symmetric = F)
b <- as.numeric(as.vector(propre[["values"]]))
lambda <- max(b)
propre[["values"]])
propre[["values"]]
print(Mat_L_anguille)
#vecteurs propres
propre <- eigen(Mat_L_anguille, symmetric = F)
b <- as.numeric(as.vector(propre[["values"]]))
lambda <- max(b)
vec_pro_d <- propre[["vectors"]]
View(vec_pro_d)
# Extraire les donn´ees en ligne
influ <- read.csv("https://xmart-api-public.who.int/FLUMART/VIW_FID?$format=csv")
# Se concentrer uniquement sur les donn´ees d'avant 2020
influ2020 <- influ[(!is.na(influ$REPORTED_CASES) & influ$ISO_YEAR < 2020),]
# Se concentrer sur les donn´ees d'un pays
pays <- influ2020[influ2020$COUNTRY_AREA_TERRITORY == "Slovenia",]
# Nombre de cas par date
dateCas <- aggregate(pays$REPORTED_CASES,
by = list(date=pays$MMWR_WEEKSTARTDATE),
FUN = "sum")
# Renommer les colonnes
colnames(dateCas) <- c("date", "cas")
# Transformer les dates en format "Date"
dateCas$date <- as.Date(dateCas$date)
# Illustration des donn´ees pour la derni`ere vague compl`ete
par(mar = c(5,5,1,1))
plot(dateCas$date, dateCas$cas/1000,
typ="l",
col="blue",
las=1,
cex.axis=1.1,
bty="L",
xaxs="i",
xlab = "Temps",
ylab = "Cas / 1000",
cex.lab = 2)
View(dateCas)
View(dateCas)
# Extraire les donnees en ligne ----
influ <- read.csv("https://xmart-api-public.who.int/FLUMART/VIW_FID?$format=csv")
# Extraire les donnees en ligne ----
influ <- read.csv("https://xmart-api-public.who.int/FLUMART/VIW_FID?$format=csv")
# Extraire les donnees en ligne ----
influ <- read.csv("https://xmart-api-public.who.int/FLUMART/VIW_FID?$format=csv")
g <- function(N, P, parms = c(b,k)){
b*N/(B+kP+N)
return(as.list(c(N,P)))
}
f <- function(N, parms = c(r, v)){
r(1-N/v) #v est N_max
return(list(N))
}
LV_base <- function(N, P, ConI, parmsf = c(r, v), parmsg = c(b,k)){ #À compléter!
with(as.list(ConI), {
# Lotka-voltera
dN <- f(N, parmsf)*N - g(N,P, parmsg)*P # dN/dt
dP <- h*g(N,P, parmsg)*P #dP/dt
# Resultat
res <- c(dN=dN, dP = dP)
return(list(res))
})
}
f <- function(N, parmsf = c(r, v)){
with(as.list(parmsf), {
r(1-N/v) #v est N_max
return(list(N))
})
}
g <- function(N, P, parmsg = c(b,k)){
with(as.list(parmsg), {
b*N/(B+kP+N)
return(list(c(N,P)))
})
}
f <- function(N, parmsf = c(r, v)){
with(as.list(parmsf), {
res_f <- r(1-N/v) #v est N_max
return(res_f)
})
}
g <- function(N, P, parmsg = c(b,k)){
with(as.list(parmsg), {
res_g <- b*N/(B+kP+N)
return(res_g)
})
}
f(20, c(r=1, v=40))
f <- function(N, parmsf = c(r, v)){
with(as.list(parmsf), {
res_f <- r*(1-N/v) #v est N_max
return(res_f)
})
}
f(20, c(r=1, v=40))
g(20, 10, c(b=1, k=1))
g <- function(N, P, parmsg = c(b,B,k)){
with(as.list(parmsg), {
res_g <- b*N/(B+kP+N)
return(res_g)
})
}
g(20, 10, c(b=1,B=2, k=1))
g <- function(N, P, parmsg = c(b,B,k)){
with(as.list(parmsg), {
res_g <- b*N/(B+k*P+N)
return(res_g)
})
}
g(20, 10, c(b=1,B=2, k=1))
CondI <- c(N=20, P=10)
LV_base(2,CondI, c(r=1,v=2), c(b=1,B=2,k=1))
}
LV_base <- function(t, ConI, parmsf = c(r, v), parmsg = c(b,B,k), parmsLV = c(h)){ #À compléter!
with(as.list(ConI), {
# Lotka-voltera
dN <- f(N, parmsf)*N - g(N,P, parmsg)*P # dN/dt
dP <- h*g(N,P, parmsg)*P #dP/dt
# Resultat
res <- c(dN=dN, dP = dP)
return(list(res))
})
}
LV_base(2,CondI, parmsf = c(r=1,v=2), parmsg = c(b=1,B=2,k=1),parmsLV = c(1))
LV_base(2,CondI, parmsf = c(r=1,v=2), parmsg = c(b=1,B=2,k=1),parmsLV = c(h=1))
LV_base(t = 2,ConI = CondI, parmsf = c(r=1,v=2), parmsg = c(b=1,B=2,k=1), parmsLV = c(h=1))
LV_base <- function(t, ConI, parmsf = c(r, v), parmsg = c(b,B,k), parmsLV = c(h)){ #À compléter!
with(as.list(ConI, parmsLV), {
# Lotka-voltera
dN <- f(N, parmsf)*N - g(N,P, parmsg)*P # dN/dt
dP <- h*g(N,P, parmsg)*P #dP/dt
# Resultat
res <- c(dN = dN, dP = dP)
return(list(res))
})
}
LV_base(t = 2,ConI = CondI, parmsf = c(r=1,v=2), parmsg = c(b=1,B=2,k=1), parmsLV = c(h=1))
LV_base <- function(t, ConI, parmsf = c(r, v), parmsg = c(b,B,k), h){ #À compléter!
with(as.list(ConI, parmsLV), {
# Lotka-voltera
dN <- f(N, parmsf)*N - g(N,P, parmsg)*P # dN/dt
dP <- h*g(N,P, parmsg)*P #dP/dt
# Resultat
res <- c(dN = dN, dP = dP)
return(list(res))
})
}
LV_base(t = 2,ConI = CondI, parmsf = c(r=1,v=2), parmsg = c(b=1,B=2,k=1), h=1)
LV_base <- function(t, ConI, parmsf = c(r, v), parmsg = c(b,B,k), h){ #À compléter!
with(as.list(ConI), {
# Lotka-voltera
dN <- f(N, parmsf)*N - g(N,P, parmsg)*P # dN/dt
dP <- h*g(N,P, parmsg)*P #dP/dt
# Resultat
res <- c(dN = dN, dP = dP)
return(list(res))
})
}
source('fct_LV5.R')
#Fonction lotka voltera avec IGP (5) ----
LV5 <- function(t, ConI, parms5 = c(a,a_prime,alpha,b,b_prime,
beta,K,m,m_prime,r)){
with(as.list(ConI, parms5), {
# Lotka-voltera
dP <- P*(b_prime*a_prime*R + beta*alpha*N - m_prime) # dP/dt
dN <- N*(a*b*R - m - alpha*P) #dN/dt
dR <- R*(r*(1-R/K) - a*N - a_prime*P) #dR/dt
# Resultat
res <- c(dP = dP, dN = dN, dR = dR)
return(list(res))
})
}
P0 <- 0.15
N0 <- 0.3
R0 <- 1 - P0 - N0
Condition_Initiale <- c(P=P0, N=N0, R=R0)
#Zone de test LV_base ----
t <- 10 #aléatoire...
a         <- 1
a_prime   <- 0.5 #entre 0 et 1 dans la fig1
alpha     <- 0.5
b         <- 1
b_prime   <- 0.5 #entre 0 et 1 dans la fig1
beta      <- 1
K         <- 1
m         <- 0.5
m_prime   <- 0.5
r         <- 1
para <- c(a=a,a_prime=a_prime,alpha=alpha,b=b,
b_prime=b_prime,beta=beta,K=K,m=m,
m_prime=m_prime,r=r)
#test fct
test_LV5 <- LV5(t, Condition_Initiale, para)
test_LV5
#test fct
test_LV5 <- LV5(seq(1,10), Condition_Initiale, para)
#test fct
test_LV5 <- LV5(seq(1,10), Condition_Initiale, para);test_LV5
#test fct
test_LV5 <- LV5(1, Condition_Initiale, para);test_LV5
#test fct
test_LV5 <- LV5(100, Condition_Initiale, para);test_LV5
#Paramètres selon la figure 1
a         <- 1
a_prime   <- 1 #entre 0 et 1 dans la fig1
alpha     <- 0.5
b         <- 1
b_prime   <- 0.25 #entre 0 et 1 dans la fig1
beta      <- 1
K         <- 1
m         <- 0.5
m_prime   <- 0.5
r         <- 1
para <- c(a=a,a_prime=a_prime,alpha=alpha,b=b,
b_prime=b_prime,beta=beta,K=K,m=m,
m_prime=m_prime,r=r)
#test fct
test_LV5 <- LV5(10, Condition_Initiale, para);test_LV5
P0 <- 15
N0 <- 30
R0 <- 100 - P0 - N0
Condition_Initiale <- c(P=P0, N=N0, R=R0)
#test fct
test_LV5 <- LV5(5, Condition_Initiale, para);test_LV5
setwd("C:/Users/Gabib/Documents/GitHub/BIO400_projetfinale")
#Première figures ----
source('fct_LV5.R')
View(test_LV5)
#Fonction Schoener avec IGP (8) ----
S8 <- function(t, ConI, parms8 = c(alpha,b,b_prime,
beta,e,e_prime,I,m,m_prime)){
with(as.list(ConI, parms8), {
# Schoener
dP <- P*((b_prime*e_prime*I)/(e_prime*P + e*N) + beta*alpha*N - m_prime) # dP/dt
dN <- N*((b*e*I)/(e_prime*P + e*N) - m - alpha*P) #dN/dt
# Resultat
res <- c(dP = dP, dN = dN)
return(list(res))
})
}
#Fonction Schoener avec IGP (8) ----
S8 <- function(t, ConI, parms8 = c(alpha,b,b_prime,
beta,e,e_prime,I,m,m_prime)){
with(as.list(ConI, parms8), {
# Schoener
dP <- P*((b_prime*e_prime*I)/(e_prime*P + e*N) + beta*alpha*N - m_prime) # dP/dt
dN <- N*((b*e*I)/(e_prime*P + e*N) - m - alpha*P) #dN/dt
# Resultat
res <- c(dP = dP, dN = dN)
return(list(res))
})
}
P0 <- 15
N0 <- 30
Condition_Initiale <- c(P=P0, N=N0)
alpha     <- 0.5
b         <- 1
b_prime   <- 1
beta      <- 1
e         <- 1
e_prime   <- 1
I         <- 1
m         <- 0.5
m_prime   <- 0.5
para <- c(alpha=alpha,b=b,b_prime=b_prime,beta=beta,e=e,
e_prime=e_prime,I=I,m=m,m_prime=m_prime)
test_S8 <- S8(5, Condition_Initiale, para);test_S8
